---
title:  "Software Engineering Best Practices"
date:   2018-04-05 16:00:00 -0500
categories: software-development
---
I recently finished [Software Engineering Best Practices](https://www.amazon.com/Software-Engineering-Best-Practices-Successful-ebook/dp/B002U2DQ5M). The content in this book is slightly different than most, in that all the findings are based on real-world data across many top software companies, instead of a single person's experiences. One of the main things I took from it was the number number one software engineering best practice. While it initially surprised me, the more you think about it the more it makes sense.

That best practice is **reuse of 100% bug free software modules.** Thinking about it logically this makes total sense, as the more code you use in your project that has been previously proven to be bug free means your project will always have certain floor of quality. However, what strange is that it's not what you might automatically think of as the number one best practice. You might think of testing, or good requirements gathering or team structure. 

What's important though is that the code you reuse has to be 100% bug free, or as close to that as realistically possible. This quality attribute can be overlooked, as reusing buggy code actually makes the project worse than if you had written it yourself, bugs and all. This goes to show the importance of software quality, as it makes more sense to create a quality software module or library that you can continuously reuse (even if it takes more time), rather than continually writing mediocre or buggy one-off code. The author compares writing code to making an investment in something. If you write high-quality code, each time you can you reuse it you are generating a positive rate of return. However, if you write buggy or low-quality code, each time you reuse it you are generating a negative rate of return, until at a certain point, it would have been better if you had never written the code in the first place. This also validates Google's approach, where they use a few core languages, so that it is easier for them to write high-quality libraries that are then shared across all the company's projects.